#!/usr/bin/python3

import fcntl
import json
import os
import time
import traceback
from base64 import urlsafe_b64encode
from pathlib import Path
from subprocess import check_output

import requests

HOST = "https://ne6r6qvt3g.re.qweatherapi.com"
ERROR = "<span color='red'>{}</span>"


def json_web_token() -> str:
    headers = urlsafe_b64encode(
        json.dumps({"alg": "EdDSA", "kid": "TBPQJBJ2NH"}).encode()
    )

    t = int(time.time())
    payload = urlsafe_b64encode(
        json.dumps(
            {
                "iat": t - 30,
                "exp": t + 600,
                "sub": "48TNTYGG4T",
            }
        ).encode()
    )

    header_payload = headers + b"." + payload
    temp = Path(f"/tmp/qweather-jwt-{t}")
    with temp.open(mode="wb") as f:
        f.write(header_payload)

    private_key = Path().home() / ".ssh/qweather.pem"
    sig = check_output(
        f"openssl pkeyutl -sign -inkey {private_key} -rawin -in {temp}",
        shell=True,
    )
    sig = urlsafe_b64encode(sig)
    temp.unlink()
    return (header_payload + b"." + sig).decode()


def get_air_quality(location: str, s: requests.Session) -> str:
    r = s.get(
        f"{HOST}/v7/air/now?location={location}",
        timeout=5,
    )
    r.raise_for_status()
    r = r.json()
    index = r["now"]
    return f"AQI: {index['aqi']}({index['category']})"


def get_location_id(location: str, s: requests.Session) -> str:
    ids = {}
    file = Path("/tmp/qweather_loc")
    if file.exists():
        with file.open() as f:
            ids = json.load(f)

            if location in ids:
                return ids[location]

    r = s.get(
        f"{HOST}/geo/v2/city/lookup?location={location}",
        timeout=5,
    )
    r.raise_for_status()
    r = r.json()
    if "code" in r and int(r["code"]) != 200:
        raise RuntimeError(f"Geoapi returned code: {r['code']}")
    loc_id = r["location"][0]["id"]
    ids[location] = loc_id

    with file.open(mode="w") as f:
        json.dump(ids, f)

    return loc_id


def qweather(location):
    s = requests.Session()
    s.headers.update({"Authorization": f"Bearer {json_web_token()}"})

    location_id = get_location_id(location, s)

    r = s.get(
        f"{HOST}/v7/weather/now?location={location_id}",
        timeout=5,
    )
    r.raise_for_status()
    d = r.json()

    n = d["now"]
    summary = f"{location} {n['text']} {n['temp']}℃"
    details = [
        f"Feels Like: {n['feelsLike']}℃",
        f"Pressure: {n['pressure']} hPa",
        f"Humidity: {n['humidity']}%",
        f"Visibility: {n['vis']} km",
        f"Wind Speed: {n['windSpeed']} km/h",
        f"Wind Direction: {n['wind360']} degree",
        f"Observation Time: {n['obsTime']}",
    ]
    if "cloud" in n:
        details.append(f"Cloudiness: {n['cloud']}%")
    details.append(get_air_quality(location_id, s))
    return summary, details


def update() -> str:
    location = os.getenv("LOCATION_CITY")
    if location is None:
        return ERROR.format("Location")

    summary = ""
    details = ["<b>qweather</b>"]
    try:
        summary, d = qweather(location)
        details += d
    except Exception:
        exception = traceback.format_exc()
        details += exception.split("\n")

    if len(summary) == 0:
        summary = ERROR.format("Error")
    details = "\r".join(details)
    return f"{summary}\n{details}"


if __name__ == "__main__":
    # temporary workaround for https://github.com/Alexays/Waybar/issues/368
    with open("/tmp/waybar_weather.lock", "w+", newline="\n", encoding="utf-8") as f:
        fcntl.flock(f, fcntl.LOCK_EX)

        t = f.readline().rstrip()
        now = int(time.time())

        if len(t) == 0 or now - int(t) > 120:
            lines = update()
            f.write(f"{now}\n{lines}")
        else:
            lines = f.read()

        print(lines)

        fcntl.flock(f, fcntl.LOCK_UN)
